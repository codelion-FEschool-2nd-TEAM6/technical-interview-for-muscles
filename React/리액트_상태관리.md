# react 상태관리

- react로 구현하다보면 `useState`를 활용하여 데이터를 저장하고 수정한다.
- 상태설계는 개발자마다 중요하게 생각하는 부분이 다르기 때문에 정답은 없다. 그리고 상태 설계는 한번 설계되어 프로젝트가 진행되면 고치기가 쉽지않다. 그래서 상태 관리에 대한 많은 고민을하고 프로젝트를 시작해야 한다. 잘못된 상태 설계는 성능 이슈는 물론 유지보수 관점에서도 큰 영향을 끼친다.

## MVC

- 초기 상태 관리는 위와 같은 MVC 방식인 ‘양방향 데이터 흐름’으로 UI를 관리했다. 예를들면, spring, django, nodejs 백엔드에서 제공하는 템플릿 UI을 사용하는 경우이다. 
- 모델 하나에 의존되는 뷰가 많아지면, controller에 복잡도가 올라가가 데이터 흐름을 이해하기 힘들고, 에러발생 시 관리에도 많은 시간이 든다.
- 이러한 문제점을 해결하기 위해 `React`가 탄생했다.

## React 

- 위의 복잡도를 해결하기 위해 단방향 흐름을 가지는 react를 릴리즈한다.
- 초기의 `React`는 전역 상태 라이브러리가 없었고,`props`로 하나씩 데이터를 전달했다. 그래서 데이터를 수정, 변경하는 비지니스 로직은 백엔드에서 하고 `React`는 받은 데이터를 UI 컴포넌트로 `props`를 활용해 보내주기만 했다. 이러한 방식을 `Flux`라고 한다.

## Flux

- Flux의 핵심은 View로 데이터가 들어가지만, 데이터나 View에서 나오지 않는 것이다.

### Flux의 흐름

1. `Action`은 버튼을 누르는 것과 같은 이벤트의 이름이다.
2. `Dispatcher`는 `Action`에서 발생한 이벤트의 이름에 따라 처리할 행동을 알려준다.
3. `Store`는 데이터가 저장되어 있는 저장소이다. `Dispatcher`에서 받은 행동에 따라 데이터를 `핸들링`한다.
4. `View`에서는 `Store`에서 데이터를 받는다. 그리고 `Action`을 통해 이벤트를 발생은 시키지만, 데이터는 전달하지 않는다.

- 위의 흐름을 바탕으로 조금씩 복잡하지게 상태관리가 발전하기 시작해서  2015년에 `React + Flux` 구조에 `Reducer`를 결합한 `Redux`가 등장했다!

## Redux

- `flux`와 `redux`의 가장 큰 차이는 `reducer`의 등장이다. 간단히 말하면, `Flux`에서는 `store`가 여러개였지만, `Redux`에서는 하나의 `store`에 여러개의 `reducer`가 존재한다고 이해를 하면 좋다.
- `client`인 `react`에 데이터를 저장하면 보안상 위험하다. 따라서  `Client`와 `Server` 사이에 `redux`라는 미들웨어를 둔다고 생각하면 된다
- 미들웨어인 `redux`와 `client`인 `react`가 데이터를 주고 받는 것이기 때문에 실질적으로 `server`와 `client`는 데이터가 무엇인지 모르고 `redux`만 데이터를 가지고 있다가 필요시 `client`의 화면에 보여주기만 하는 것이다. 이러한 이유로 `redux`가 사용되기도 한다.
- 기본적으로 `Redux`를 사용하지 않으면 우리는 데이터를 `props`로 컨포넌트간에 전달을 시켰다. 이러한 데이터는 전달된 컨포넌트에 국한되어 영향을 주는 지역상태이다.
- `Redux`는 많은 컴포넌트에 영향을 주는 `전역상태`이다.
- 여전히 `Redux`는 대세로 쓰이고 있고 많은 프로젝트에서 전역상태가 무분별하게 사용되고있다. 그래서 전역 상태 라이브러리를 안쓰는게 좋다는 흐름이 생기고 있고 리액트팀에서는 `Recoil`을 만들어서 기존의 전역상태 라이브러리를 대체하려고 하고 있다.

## Context API

- `redux` 이 후에 `Hooks`이 나오면서 비대한 `Redux` 대신 `Context API`를 활용해서 하는 개발이 권장 된다. `Context API` 자체는 상태관리를 `Redux`의 `useState`와 `useReducer`로 한다. 하지만 `Redux`와 가장 큰 차이점은 `Provider`를 나눠서 관리가 가능하고, 최상단이 아닌 관련된 컴포넌트 들의 상위에 `Provider`를 감싸기만 하면 되기 때문에 데이터가 필요한 컴포넌트들에서만 상태를 관리 할 수 있다.

- 그러나 사용하는 값이 변할때 리렌더링 되는 것에 최적화 되어 있는 `Redux`와 달리 `Context API`는 해당 값 외의 다른 값이 변경될때도 컴포넌트가 재호출되어 `리렌더링`이 발생한다. 따라서 목표 값에 따라 분리 해서 관리를 해야하는데, 목표 값이 많아 질 수록 컴포넌트가 많아져서 성능 이슈가 발생한다. 이러한 명확한 한계로 인해 리액트 팀은 `Recoil`을 만들기 시작하고 있다.

## Recoil 

- `Redux, Mobx`와 달리 `Recoil`은 리액트 만을 위해 생긴 라이브러리다. `Recoil`은 `Atom`이라는 작은 데이터 조각을 만들어 해당 데이터 변화 시에 이를 참고하는 컴포넌트들만 `re-render` 시킨다. 사용자가 많이 없기 때문에 초입자라면, `redux`를 먼저 사용하는 것이 좋다.

## 최고의 상태관리 라이브러리

- 기본적으로는 모든 상태 관리 라이브러리를 사용해 보는 것을 추천한다.
- 기본적으로는 커뮤니티가 큰 Redux로 시작하는것이 당연히 좋다. 그러나 기본적으로 상태와 변이방법을 정의하기 위한 `redux`와 `action`의 코딩량이 많은데다가, 지속적으로 로컬 스토어 상태를 원격 서버 상태와 동기화를 위한 `saga`같은 미들웨어가 추가되면 기능 하나당 추가해야하는 코딩량은 더 많아진다.
- 사실 정답은 없다.(어질어질하네;;) 규모가 작다면 비교적 쉽게 적용할 수 있는 `context API`를 사용하는 것이 좋고, 규모가 크고 확장성이 있고 비동기처리가 필요하다면 `redux, thunk, saga`까지 고려가 필요하다. 하지만 무언가를 판단을 하기 위해서는 시대의 흐름에 주류가 되는 기술`redux`을 경험해 본 후에 다른 라이브러리를 적용해야 한다고 생각한다.

## 라이브러리

- angular : 프레임워크의 한계로 data 상태가 blackbox 되는 치명적 문제가 있어, 점유율 감소 중 => 비추
- react : 치명적 문제는 아직 발견 되지 않음. 향후 5년은 문제 없음 => 추천
- redux: 대표적인 react 상태관리 라이브러리 => 추천(redux toolkit 추천)
- redux-actions : redux 코드를 줄여준다 => 추천
- react-saga : redux의 비동기 문제인 Side Effect를 훌륭히 관리한다. => 추천
위의 이유로 redux의 단점은 코드가 길어진다. 그에 따른 대안으로 SWR 이나 recoil이 나왔다.
SWR, recoil은 위의 추천 라이브러리를 먼저 사용한 프로젝트를 진행 후에 적용을 하는 것을 고민해 보면 좋을 것 같다.
- SWR은 상태관리 툴은 아니지만, API 기능으로도 상태관리가 가능하다. => 추천